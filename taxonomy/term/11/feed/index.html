<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xml:base="http://cmsc411.com"  xmlns:dc="http://purl.org/dc/elements/1.1/">
<channel>
 <title>CMSC411 - Hardware</title>
 <link>http://cmsc411.com/topics/hardware</link>
 <description></description>
 <language>en</language>
<item>
 <title>References</title>
 <link>http://cmsc411.com/hardware/references-0</link>
 <description>&lt;div class=&quot;field field-name-body field-type-text-with-summary field-label-hidden&quot;&gt;&lt;div class=&quot;field-items&quot;&gt;&lt;div class=&quot;field-item even&quot; property=&quot;content:encoded&quot;&gt;&lt;p&gt;These references are all online sources, due to the lack of up-to-date published books on the topic of overclocking.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.overclock.net/t/1247413/ivy-bridge-overclocking-guide-with-ln2-guide-at-the-end&quot;&gt;http://www.overclock.net/t/1247413/ivy-bridge-overclocking-guide-with-ln2-guide-at-the-end&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.overclock.net/t/1198504/complete-overclocking-guide-sandy-bridge-ivy-bridge-asrock-edition&quot;&gt;http://www.overclock.net/t/1198504/complete-overclocking-guide-sandy-bridge-ivy-bridge-asrock-edition&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.anandtech.com/show/5771/the-intel-ivy-bridge-core-i7-3770k-review&quot;&gt;http://www.anandtech.com/show/5771/the-intel-ivy-bridge-core-i7-3770k-review&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.bit-tech.net/hardware/cpus/2012/05/01/intel-core-i5-3570k-cpu-review/8&quot;&gt;http://www.bit-tech.net/hardware/cpus/2012/05/01/intel-core-i5-3570k-cpu-review/8&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://commons.wikimedia.org/wiki/File:Computer_Heatsinks(2).jpg&quot;&gt;http://commons.wikimedia.org/wiki/File:Computer_Heatsinks(2).jpg&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.anandtech.com/show/6894/best-high-end-z77-motherboards-april-2013&quot;&gt;http://www.anandtech.com/show/6894/best-high-end-z77-motherboards-april-2013&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description>
 <pubDate>Sat, 17 Aug 2013 02:51:35 +0000</pubDate>
 <dc:creator>rji</dc:creator>
 <guid isPermaLink="false">284 at http://cmsc411.com</guid>
 <comments>http://cmsc411.com/hardware/references-0#comments</comments>
</item>
<item>
 <title>Glossary</title>
 <link>http://cmsc411.com/hardware/glossary-0</link>
 <description>&lt;div class=&quot;field field-name-body field-type-text-with-summary field-label-hidden&quot;&gt;&lt;div class=&quot;field-items&quot;&gt;&lt;div class=&quot;field-item even&quot; property=&quot;content:encoded&quot;&gt;&lt;p&gt;&lt;strong&gt;Clock rate&lt;/strong&gt;: a measure of how many clock cycles a CPU completes per unit of time.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Overclocking&lt;/strong&gt;: the process of configuring your CPU to run at a higher clock rate than the default set by the manufacturer.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CPU multiplier&lt;/strong&gt;: the multiplier that is applied to the front-side bus frequency to obtain the CPU clock rate.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Front-side bus frequency&lt;/strong&gt;: the frequency at which the motherboard’s front-side bus runs. The CPU, RAM, and PCI frequencies are multiples of the FSB frequency.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Stress test&lt;/strong&gt;: running a computationally-intensive program (such as Prime95) in order to check whether an overclocking configuration is stable or not.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description>
 <pubDate>Sat, 17 Aug 2013 02:35:05 +0000</pubDate>
 <dc:creator>rji</dc:creator>
 <guid isPermaLink="false">283 at http://cmsc411.com</guid>
 <comments>http://cmsc411.com/hardware/glossary-0#comments</comments>
</item>
<item>
 <title>Post-test</title>
 <link>http://cmsc411.com/hardware/post-test-0</link>
 <description>&lt;div class=&quot;field field-name-body field-type-text-with-summary field-label-hidden&quot;&gt;&lt;div class=&quot;field-items&quot;&gt;&lt;div class=&quot;field-item even&quot; property=&quot;content:encoded&quot;&gt;&lt;p&gt;&lt;strong&gt;Test Questions&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;When would you adjust the front-side bus frequency instead of the CPU multiplier?&lt;/li&gt;
&lt;li&gt;What are some of the drawbacks of a higher CPU clock rate?&lt;/li&gt;
&lt;li&gt;Under what circumstances would you have to decrease the CPU voltage?&lt;/li&gt;
&lt;li&gt;What is the relationship between clock rate, front-side bus frequency, and CPU multiplier?&lt;/li&gt;
&lt;li&gt;What problems can arise due to insufficient CPU voltage and how would you detect them?&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;Answers&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;You would adjust the front-side bus frequency instead of the CPU multiplier if your CPU does not have an unlocked multiplier. The problem with adjusting the front-side bus frequency is that it affects the RAM and PCI cards in addition to the CPU.&lt;/li&gt;
&lt;li&gt;A higher clock rate requires additional voltage, more power, higher temperatures, and can lead to a shorter CPU lifespan.&lt;/li&gt;
&lt;li&gt;If you find that the CPU temperature exceeds acceptable bounds during use, you will have to lower the CPU voltage.&lt;/li&gt;
&lt;li&gt;Clock rate = front-side bus frequency * CPU multiplier.&lt;/li&gt;
&lt;li&gt;Insufficient CPU voltage can result in computational errors, which can prevent the computer from booting or cause unexpected crashes. You can detect such errors by running a stress test.&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description>
 <pubDate>Sat, 17 Aug 2013 02:31:39 +0000</pubDate>
 <dc:creator>rji</dc:creator>
 <guid isPermaLink="false">281 at http://cmsc411.com</guid>
 <comments>http://cmsc411.com/hardware/post-test-0#comments</comments>
</item>
<item>
 <title>Ensuring stability</title>
 <link>http://cmsc411.com/hardware/ensuring-stability</link>
 <description>&lt;div class=&quot;field field-name-body field-type-text-with-summary field-label-hidden&quot;&gt;&lt;div class=&quot;field-items&quot;&gt;&lt;div class=&quot;field-item even&quot; property=&quot;content:encoded&quot;&gt;&lt;p&gt;When adjusting your CPU’s clock rate and voltages, you might end up in a configuration where the CPU is not receiving enough voltage for the chosen clock rate. This can cause the CPU to produce incorrect results for some percentage of its calculations. In some cases, this can cause the computer to refuse to start up. In other cases, the computer is able to boot, but calculation errors still occur intermittently, which can lead to unexpected crashes.&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/sites/default/files/files/overclocking/prime95.png&quot; style=&quot;width: 600px; height: 622px;&quot; /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;strong&gt;&lt;em&gt;Above: a screenshot of the Prime95 software, taken by the author of this guide.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Stress testing is used to detect this type of situation and help ensure that your overclocking configuration is stable and error-free. By far the most popular program used for stress testing when overclocking is Prime95, though other CPU-intensive programs may be used for this purpose as well. The testing method is to run the program for an extended period of time, then check whether any errors were either detected by the program itself (for example, Prime95 has a built-in feature to check the results of calculations for errors), or recorded in the operating system’s logs. If any errors occurred, the solution is to either increase the CPU voltage or decrease the CPU clock rate.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description>
 <pubDate>Sat, 17 Aug 2013 02:28:29 +0000</pubDate>
 <dc:creator>rji</dc:creator>
 <guid isPermaLink="false">279 at http://cmsc411.com</guid>
 <comments>http://cmsc411.com/hardware/ensuring-stability#comments</comments>
</item>
<item>
 <title>CPU multiplier, front-side bus frequency, and CPU voltage</title>
 <link>http://cmsc411.com/hardware/cpu-multiplier-front-side-bus-frequency-and-cpu-voltage</link>
 <description>&lt;div class=&quot;field field-name-body field-type-text-with-summary field-label-hidden&quot;&gt;&lt;div class=&quot;field-items&quot;&gt;&lt;div class=&quot;field-item even&quot; property=&quot;content:encoded&quot;&gt;&lt;p&gt;To start overclocking, you’ll need to modify settings in your motherboard’s BIOS (or UEFI in newer systems). There might be an overwhelming array of options to choose from – don’t panic! For the purposes of this guide, we’ll focus on just three important settings.&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/sites/default/files/files/overclocking/uefi.png&quot; style=&quot;width: 600px; height: 449px;&quot; /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;strong&gt;&lt;em&gt;Above: an example of a UEFI settings panel.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CPU Multiplier&lt;/strong&gt;: The CPU clock rate is specified as a multiple of the front-side bus frequency: CPU clock rate = front-side bus frequency * CPU multiplier. Adjusting the CPU multiplier allows you to change the CPU’s clock rate without affecting any of the other components on the motherboard. However, not all processors allow their CPU multiplier to be changed.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Front-Side Bus Frequency&lt;/strong&gt;: The front-side bus frequency affects not only the CPU frequency, but also the RAM frequency and the frequency of the PCI cards attached to your motherboard. As such, trying to overclock your CPU by increasing the front-side bus frequency can have unintended consequences, since it affects other components on the motherboard. However, if your CPU does not have an unlocked multiplier, adjusting the front-side bus frequency may be the only way of increasing your CPU’s clock rate.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CPU Voltage&lt;/strong&gt;: There are two ways to specify the voltage to be applied to the CPU – “fixed mode” and “offset mode”. In fixed mode, you specify a constant voltage to be applied to the CPU at all times. To use fixed mode, you should first determine what the typical voltage is for the CPU without overclocking – either by checking the documentation or doing empirical testing yourself – then increase the voltage with respect to that baseline. In offset mode, you allow the motherboard to determine a voltage based on the CPU load, then add an offset on top of the automatically-chosen voltage. Either method can be used to increase the CPU voltage during overclocking.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description>
 <pubDate>Sat, 17 Aug 2013 02:24:47 +0000</pubDate>
 <dc:creator>rji</dc:creator>
 <guid isPermaLink="false">277 at http://cmsc411.com</guid>
 <comments>http://cmsc411.com/hardware/cpu-multiplier-front-side-bus-frequency-and-cpu-voltage#comments</comments>
</item>
<item>
 <title>The overclocking process</title>
 <link>http://cmsc411.com/hardware/overclocking-process</link>
 <description>&lt;div class=&quot;field field-name-body field-type-text-with-summary field-label-hidden&quot;&gt;&lt;div class=&quot;field-items&quot;&gt;&lt;div class=&quot;field-item even&quot; property=&quot;content:encoded&quot;&gt;&lt;p&gt;Overclocking is a process of trial and error. The goal is to find a balance point that maximizes your CPU’s clock rate while keeping the voltage at an acceptable level. The higher the clock rate, the higher the voltage your CPU requires. If the voltage is too low for the chosen clock rate, the CPU may start to produce erroneous results for some calculations, which can cause the computer to refuse to boot in some cases, or lead to transient crashes in others. On the other hand, increasing the voltage causes the CPU to generate more heat, which can damage the CPU and shorten its effective lifespan. Some CPUs have a built-in thermometer and will start to throttle back once it reaches a certain temperature limit. As such, the temperature threshold imposes a limit on how high the CPU’s clock rate can effectively be set.&lt;/p&gt;
&lt;p&gt;A typical overclocking strategy is as follows:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Increase the CPU clock rate.&lt;/li&gt;
&lt;li&gt;Run a stress test. Check for errors and monitor the CPU’s temperature during the test.&lt;/li&gt;
&lt;li&gt;Take action based on the results:&lt;/li&gt;
&lt;/ol&gt;&lt;ul style=&quot;margin-left: 40px;&quot;&gt;&lt;li&gt;If the temperature exceeded the acceptable limit, then decrease the CPU voltage.&lt;/li&gt;
&lt;li&gt;If any errors occurred, then increase the CPU voltage – unless the temperature limit has already been reached, in which case the CPU clock rate should be decreased.&lt;/li&gt;
&lt;li&gt;Otherwise, continue to increase the CPU clock rate.&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description>
 <pubDate>Sat, 17 Aug 2013 02:17:53 +0000</pubDate>
 <dc:creator>rji</dc:creator>
 <guid isPermaLink="false">276 at http://cmsc411.com</guid>
 <comments>http://cmsc411.com/hardware/overclocking-process#comments</comments>
</item>
<item>
 <title>Requirements for overclocking</title>
 <link>http://cmsc411.com/hardware/requirements-overclocking</link>
 <description>&lt;div class=&quot;field field-name-body field-type-text-with-summary field-label-hidden&quot;&gt;&lt;div class=&quot;field-items&quot;&gt;&lt;div class=&quot;field-item even&quot; property=&quot;content:encoded&quot;&gt;&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/sites/default/files/files/overclocking/motherboard.png&quot; style=&quot;width: 600px; height: 356px;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A motherboard that allows you to change the necessary settings&lt;/strong&gt;: Make sure that the motherboard that you are using allows you to adjust the CPU voltage and the front-side bus frequency, at the very least.&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/sites/default/files/files/overclocking/i5-3570k.png&quot; style=&quot;width: 600px; height: 553px;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A CPU with an unlocked multiplier&lt;/strong&gt;: Some processors are made with “locked multipliers”, meaning that the CPU multiplier cannot be changed. Manufacturers will typically charge a bit extra for the “unlocked” version of that CPU. While an unlocked multiplier is not strictly necessary, it makes the task of overclocking much easier and allows you to fine-tune your CPU clock rate without affecting the other components on your motherboard.&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/sites/default/files/files/overclocking/heatsink.png&quot; style=&quot;width: 600px; height: 400px;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A high-quality heat sink and case&lt;/strong&gt;: Since overclocking your CPU will typically cause it to generate more heat, ensure that you have a decent heat sink and adequate air flow in your computer case, to prevent your CPU from overheating.&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/sites/default/files/files/overclocking/prime95.png&quot; style=&quot;width: 600px; height: 622px;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Stress testing software&lt;/strong&gt;: It is important to ensure that your CPU configuration is stable and not prone to computational errors. A common way to check for stability is to run a program that makes heavy use of the CPU, and see if any errors occurred during the program’s execution.&lt;br /&gt; &lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description>
 <pubDate>Sat, 17 Aug 2013 02:11:04 +0000</pubDate>
 <dc:creator>rji</dc:creator>
 <guid isPermaLink="false">275 at http://cmsc411.com</guid>
 <comments>http://cmsc411.com/hardware/requirements-overclocking#comments</comments>
</item>
<item>
 <title>What is overclocking?</title>
 <link>http://cmsc411.com/hardware/what-overclocking</link>
 <description>&lt;div class=&quot;field field-name-body field-type-text-with-summary field-label-hidden&quot;&gt;&lt;div class=&quot;field-items&quot;&gt;&lt;div class=&quot;field-item even&quot; property=&quot;content:encoded&quot;&gt;&lt;p&gt;CPU overclocking is the process of configuring your CPU to run at a higher clock rate than the default set by the manufacturer. This lets you get more bang for your buck in terms of processor speed and performance.&lt;/p&gt;
&lt;p&gt;So if a CPU has the potential to run at a higher clock rate, why doesn’t the manufacturer set it to run at the higher rate by default?&lt;/p&gt;
&lt;p&gt;That&#039;s because overclocking comes with a set of tradeoffs.  An increased clock rate can lead to higher power consumption, an increase in the voltage required by the CPU, increased operating temperatures, as well as a decrease in the CPU’s lifespan. In addition, due to variations in the manufacturing process, not all CPUs of the same model are necessarily identical – not even CPUs cast from the same die. Some CPUs will have slight defects, such that they still work, but not as effectively as a perfect specimen would have.&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;/sites/default/files/files/overclocking/ivy-bridge.png&quot; style=&quot;width: 600px; height: 252px;&quot; /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;strong&gt;&lt;em&gt;Above: CPU die for an Intel Ivy Bridge processor.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In order to account for these issues, CPU manufacturers will typically choose a relatively conservative default clock rate, so that the majority of chips will work smoothly out of the box. However, if you are willing to go through some trial-and-error and do some problem solving, you can often find a better balance point that allows your CPU to have a higher clock rate while still remaining within acceptable bounds for power consumption, temperature, and error rate.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description>
 <pubDate>Sat, 17 Aug 2013 02:04:49 +0000</pubDate>
 <dc:creator>rji</dc:creator>
 <guid isPermaLink="false">274 at http://cmsc411.com</guid>
 <comments>http://cmsc411.com/hardware/what-overclocking#comments</comments>
</item>
<item>
 <title>Pre-test</title>
 <link>http://cmsc411.com/hardware/pre-test</link>
 <description>&lt;div class=&quot;field field-name-body field-type-text-with-summary field-label-hidden&quot;&gt;&lt;div class=&quot;field-items&quot;&gt;&lt;div class=&quot;field-item even&quot; property=&quot;content:encoded&quot;&gt;&lt;ol&gt;&lt;li&gt;When would you adjust the front-side bus frequency instead of the CPU multiplier?&lt;/li&gt;
&lt;li&gt;What are some of the drawbacks of a higher CPU clock rate?&lt;/li&gt;
&lt;li&gt;Under what circumstances would you have to decrease the CPU voltage?&lt;/li&gt;
&lt;li&gt;What is the relationship between clock rate, front-side bus frequency, and CPU multiplier?&lt;/li&gt;
&lt;li&gt;What problems can arise due to insufficient CPU voltage and how would you detect them?&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description>
 <pubDate>Sat, 17 Aug 2013 01:52:39 +0000</pubDate>
 <dc:creator>rji</dc:creator>
 <guid isPermaLink="false">273 at http://cmsc411.com</guid>
 <comments>http://cmsc411.com/hardware/pre-test#comments</comments>
</item>
<item>
 <title>Hardware Wars: Exploiting Instruction-Level Parallelism (ILP)</title>
 <link>http://cmsc411.com/hardware/hardware-wars-exploiting-instruction-level-parallelism-ilp</link>
 <description>&lt;div class=&quot;field field-name-body field-type-text-with-summary field-label-hidden&quot;&gt;&lt;div class=&quot;field-items&quot;&gt;&lt;div class=&quot;field-item even&quot; property=&quot;content:encoded&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;This image shows IBM 360/91, the first processor to use Tomasulo&#039;s Algorithm, making it the fastest processor in 1968.  The study of computer architecture focuses on how computer hardware runs computer software.  The processor plays an important role in computer architecture by managing this interaction:  The processor is computer hardware that carries out the instructions of a computer program.  The goal of this webpage will be to define and discuss features of different processor designs focusing on how each feature improves instruction-level parallelism.  This includes designs that are scalar or superscalar, designs that incorporate Tomasulo&#039;s Algorithm, and each will use static branch prediction.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;a id=&quot;top&quot; name=&quot;top&quot;&gt;top&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;a href=&quot;#introduction&quot;&gt;1. introduction&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;#ILP_problems&quot;&gt;2. ILP problems&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;#scheduling&quot;&gt;3. scheduling&lt;/a&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;a href=&quot;static scheduling&quot;&gt;    &lt;/a&gt;&lt;a href=&quot;#static_scheduling&quot;&gt;3.1 static scheduling&lt;/a&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;a href=&quot;#dynamic_scheduling&quot;&gt;    3.2 dyanmic scheduling&lt;/a&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;a href=&quot;#issuing&quot;&gt;4. issuing&lt;/a&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;a href=&quot;#single_issue&quot;&gt;    4.1 single issue&lt;/a&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;a href=&quot;#multiple_issue&quot;&gt;    4.2 multiple issue&lt;/a&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;a href=&quot;#branch_prediction&quot;&gt;5. branch prediction&lt;/a&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;a href=&quot;#static_branch_prediction&quot;&gt;    5.1 static branch prediction&lt;/a&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;a href=&quot;#designs&quot;&gt;6. Processor Designs&lt;/a&gt;&lt;br /&gt;    &lt;a href=&quot;#design_1&quot;&gt;6.1 Design 1: Scalar, Static Scheduling, Static branch prediction&lt;/a&gt;&lt;br /&gt;    &lt;a href=&quot;#design_2&quot;&gt;6.2 Design 2: Scalar, Dynamic Scheduling, Static branch prediction&lt;/a&gt;&lt;br /&gt;  &lt;a href=&quot;#design_3&quot;&gt;  6.3 Design 3: Superscalar, Dynamic Scheduling, Static branch prediction&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;#exercises&quot;&gt;6. exercises&lt;/a&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;a href=&quot;#references&quot;&gt;7. references&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;a id=&quot;introduction&quot; name=&quot;introduction&quot;&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;introduction&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;The study of computer architecture focuses on how computer hardware runs computer software.  The processor plays an important role in computer architecture by managing this interaction:  The processor is computer hardware that carries out the instructions of a computer program.  The goal of this webpage will be to define and discuss features of different parallel processor designs focusing on how each feature improves instruction-level parallelism.  This includes designs that are scalar or superscalar, designs that incorporate Tomasulo&#039;s Algorithm, and each will use static branch prediction.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;a href=&quot;#top&quot;&gt;top&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;a id=&quot;ILP_problems&quot; name=&quot;ILP_problems&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;ILP problems&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;The performance improvement of the parallel processor over the sequential processor relies on the parallel processor overlapping instruction processing. Not initially obvious, an ideal CPI &amp;lt;= 1 on a parallel processor can only be gauranteed if instructions are independent.  Unfortunately, many issues arise from using ILP because instructions are not always independent.  These problems are not present in a sequential machine because in a sequential machine each instruction is run to completion before the next instruction can be initiated.  In a parallel processor instruction processing overlap during runtime can create dependences which result in hazards if not resolved.  These issues even when resolved often cannot keep the ideal CPI &amp;lt;= 1  reducing the desired performance, but usually still provide an improvement over the sequential processor.  Below lists the dependences and hazards that arise in a parallel processor.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;em&gt;dependences -- software&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;data dependences: one instruction requires the output from another instruction before it can be completely processed&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;name dependences: two instructions use the same register or memory location, but they do not share data&lt;/span&gt;
&lt;ol&gt;&lt;li&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;antidependence: one instruction writes to a register that an earlier instruction reads &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;output dependence: one instruction writes to the same register as another instruction&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;control dependences: an instruction who processing is determined by a branch instruction&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;em&gt;hazards -- hardware&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;data hazards: a result of unresolved data dependences&lt;/span&gt;
&lt;ol&gt;&lt;li&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;RAW (read after write): data is read before the correct data can be written (unresolved data dependence)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;WAW (write after write):&lt;/span&gt;&lt;span style=&quot;font-size:14px;&quot;&gt; data is written out of order (unresolved output dependence)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;WAR (write after read): data is written before the correct data can be read (unresolved antidependence)&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;structural hazards: resource contention&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;control hazards: incorrect exeception behavior or data flow (unresolved control dependence)&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;a href=&quot;#top&quot;&gt;top&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;a id=&quot;scheduling&quot; name=&quot;scheduling&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;scheduling&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;To exploit performance improvements of ILP, s&lt;/span&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;cheduling techniques attempt to arrange instructions such that only independent instructions overlap.  Hardware expoits parallelism using dynamic scheduling and software exploits parallelism using static scheduling at compile time.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;a href=&quot;#top&quot;&gt;top&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;a id=&quot;static_scheduling&quot; name=&quot;static_scheduling&quot;&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;strong&gt;static scheduling&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;The pipe-like-pipe processor utilizes static scheduling to improve performance.  In a pipe-like-pipe processor the compiler statically schedules instructions to keep the pipeline full, to avoid hazards without changing dependences, and to minimize stalls. To avoid hazards without a stall the static scheduler separates a dependent instruction from its source instruction by the pipeline clock cycle latency of that source instruction.  Strong static scheduling relies on the percentage of instructions that can be overlapped without potential hazards and the functional unit latencies.  Static scheduling that implements branch delay slot and loop unrolling resolve some hazards caused by branches.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;branch delay slot&lt;/span&gt;&lt;/em&gt;&lt;span style=&quot;font-size:14px;&quot;&gt; puts an instruction following a branch instruction to provide enough time for the evaluation of the branch instruction.  This prevents control hazards at runtime.  This scheme is limited by instructions put into the delay slot and predicting branch direction at compile time.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;loop unrolling&lt;/span&gt;&lt;/em&gt; &lt;span style=&quot;font-size:14px;&quot;&gt;converts loop level parallelism into instruction level parallelism statically by the compiler.  More than one iteration of  branch can be scheduled together to eliminate hazards.  This scheme is more instructions and needs more registers.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;a href=&quot;#top&quot;&gt;top&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;a id=&quot;dynamic_scheduling&quot; name=&quot;dynamic_scheduling&quot;&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;dynamic scheduling&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;Dynamic scheduling performs better and therefore replaced pipe-like-pipe architecture.  Dynamic scheduling allows out-of-order execution that occurs during runtime by the hardware.  Tomosulo&#039;s Algorithm is a dynamic scheduling algorithm that was first used in the IBM 360/91.&lt;/span&gt;  &lt;span style=&quot;font-size:14px;&quot;&gt;Resolves name dependences using register renaming and resolves true data dependences by waiting for operands before entering a functional unit.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://docs.google.com/document/d/134JGjC5mdd_laBAquPKYqrKg2fmZPYjNDJGILZp4o1g/pubimage?id=134JGjC5mdd_laBAquPKYqrKg2fmZPYjNDJGILZp4o1g&amp;amp;image_id=1RfRF4JUGTu-ixGqXeETQ6-tLOa7w0M6lvOoCCA&quot; /&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;Basic Tomosulo algorithm consists of three stages&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;Issue:  The issue stage gets an instruction from the instruction queue and puts it into an empty slot in its corresponding reservation station with any operands currently in the registers.  Then waits in the reservation station for all operands not in registers.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;Execute: performs the operation indicated by the instruction&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;Write Result: output is written to the common data bus (CDB) to be sent to registers and waiting reservation stations&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;This scheme provides many benefits to older schemes.  Tomosulo&#039;s Algorithm resolves name dependences using register renaming provided by the reservation statitions including output dependences and antidependences thus eliminating WAW and WAR hazards using register &lt;em&gt;register renaming&lt;/em&gt;&lt;/span&gt;.  &lt;span style=&quot;font-size:14px;&quot;&gt;Dynamically scheduling instructions helps eliminate many of the stalls required in the pipe-like-pipe.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;a href=&quot;#top&quot;&gt;top&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;a id=&quot;issuing&quot; name=&quot;issuing&quot;&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;strong&gt;issuing&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;Issuing describes the number of instructions that can be issued in a clock cycle.  The goal of processor designs is to issue many instructions each clock cycle.  This is restricted by dependences in the software and hazards in the hardware.  Issuing is either scalar, single issue, or superscalar, multiple issue.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;a href=&quot;#top&quot;&gt;top&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;a id=&quot;single_issue&quot; name=&quot;single_issue&quot;&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;strong&gt;single issue (scalar) &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;ideal CPI = 1 complete one instruction per clock cycle&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;Scalar processing is the goal of the pipe-like-pipe, often prevented by dependences, but scalar is more easily achieved on a dynamic scheduler where an ideal CPI &amp;lt; 1.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;a href=&quot;#top&quot;&gt;top&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;a id=&quot;multiple_issue&quot; name=&quot;multiple_issue&quot;&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;strong&gt;multiple issue (superscalar) &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;ideal CPI &amp;lt; 1&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;superscalar processor issue multiple instructions per clock cycle.  This involve more hardware, but provides improvements to performance.  Superscalar can be implemented on static schedulers and dynamic schedulers.  VLIW is a static scheduler that accomplishes multiple issue by packaging multiple instructions into a large instruction.  A superscalar processor implementing Tomasulo&#039;s algorithm fills a window with independent instructions that can be run in parallel absent of hazards. &lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;a href=&quot;#top&quot;&gt;top&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;a id=&quot;branch_prediction&quot; name=&quot;branch_prediction&quot;&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;strong&gt;branch prediction&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;Control hazards can reduce performance.  Branch prediction schemes were designed to reduce branch penalties. Branch prediction schemes use different strategies to accurately predicts when a branch should and should not be taken.  Static branch predicition schemes are basic schemes that happen at compile time.  Dynamic branch prediction schemes involve more complex decision making scheme to improve the performance.  Static branch prediction schemes are the focus and see exercise to learn more about dynamic branch prediction schemes.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;a href=&quot;#top&quot;&gt;top&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;a id=&quot;static_branch_prediction&quot; name=&quot;static_branch_prediction&quot;&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;strong&gt;static branch prediction&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;S&lt;/span&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;tatic branch prediction occurs during compile time.  These static branch prediction schemes include predict taken, untaken or branch predictions based on behaviors observed in previous runs of the branch instruction.  Resolving mispredictions requires flushing the pipeline.  These schemes tend to be inaccurate providing many mispredictions.  This led to dynamic branch prediction schemes (See exercise).&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;a href=&quot;#top&quot;&gt;top&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;a id=&quot;designs&quot; name=&quot;designs&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;Processor Designs&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;Different combinations of processor feature can provide improvements to the processor.  Over time the goal has been to find the right combination of features to maximize performance.  The following designs show how the processor design has changed and improved over time.  A fourth design can be explored further in the exercise.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;a href=&quot;#top&quot;&gt;top&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;design_1&quot; name=&quot;design_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;Design 1: Scalar, Static Scheduling, Static branch prediction&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;This first design is the most basic and earliest implemented design.  It presents many of the initial problems associated with parallel processing and generated solutions such as forwarding and stalling to prevent hazards caused by dependences.  Unfortunately, this design is not able to eliminate a significant enough number of stalls&lt;/span&gt;,&lt;span style=&quot;font-size:14px;&quot;&gt; so dynamic strategies were enlisted.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;a href=&quot;#top&quot;&gt;top&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;design_2&quot; name=&quot;design_2&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;Design 2: Scalar, Dynamic Scheduling, Static branch prediction&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;This design uses a basic implementation of Tomasulo&#039;s algorithm that handles many of the problems that came from the pipe-like-pipe and handles dependences better.  Here the only change is in the scheduling, which replaces the processor hardware to allow for out-of-order execution dynamically.  This eliminates stalls that were unnecessary in a pipe-like-pipe.  Further improvements can be made to improve this scheme.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;a href=&quot;#top&quot;&gt;top&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;design_3&quot; name=&quot;design_3&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;Design 3: Superscalar, Dynamic Scheduling, Static branch prediction&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;This third design improves performance over the first two designs because multiple instructions can be issued in one clock cycle and dynamic scheduling allows for efficient handling of dependences.  The only weakness here is the static branch prediction which can have a negative impact on performance.  The final design explored in the excercise implements dynamic branch prediction which is the last piece to improve performance beyond all three of these designs.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;a href=&quot;#top&quot;&gt;top&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;a id=&quot;exercises&quot; name=&quot;exercises&quot;&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;strong&gt;exercise&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Static branch prediction schemes do not provide strong accuracy or high performance.  Limitations on static branch prediction led to the development of dyanmic branch predictions or speculative schemes, which resolved some of these problems.  Describe the behavior of dynamic branch prediction schemes including Branch Prediction Buffer (BPB), Branch Target Buffer (BTB) and Branch Folding Buffer (BFB).  Then compare and contrast a superscalar processor that uses dynamic scheduling and dynamic branch prediction (Superscalar Speculative Tomasulo (SST)) to some of the other processor designs discussed.  Does this design improve upon some of the older designs? Explain why or why not.&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;a href=&quot;#top&quot;&gt;top&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;a id=&quot;references&quot; name=&quot;references&quot;&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;strong&gt;references&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;cite&gt;John L. Hennessy, J. L., Patterson, D. A. (2007) &lt;em&gt;Computer Architecture A Quantitative Approach&lt;/em&gt; (4th ed.). San Francisco, CA: Elsevier, Inc.&lt;/cite&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;Epic Cheat Sheet&lt;br /&gt;&lt;a href=&quot;https://docs.google.com/document/d/134JGjC5mdd_laBAquPKYqrKg2fmZPYjNDJGILZp4o1g/pub&quot;&gt;https://docs.google.com/document/d/134JGjC5mdd_laBAquPKYqrKg2fmZPYjNDJGI...&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;image of IBM 360/91&lt;br /&gt;&lt;a href=&quot;http://people.tribe.net/smbeachbear/photos/4bc9e912-0553-43ea-91ee-0bedb7cdf2ca&quot;&gt;http://people.tribe.net/smbeachbear/photos/4bc9e912-0553-43ea-91ee-0bedb...&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;a href=&quot;#top&quot;&gt;top&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;field field-name-field-attachment field-type-file field-label-above&quot;&gt;&lt;div class=&quot;field-label&quot;&gt;Attachment(s):&amp;nbsp;&lt;/div&gt;&lt;div class=&quot;field-items&quot;&gt;&lt;div class=&quot;field-item even&quot;&gt;&lt;span class=&quot;file&quot;&gt;&lt;img class=&quot;file-icon&quot; alt=&quot;&quot; title=&quot;application/pdf&quot; src=&quot;/modules/file/icons/application-pdf.png&quot; /&gt; &lt;a href=&quot;http://cmsc411.com/sites/default/files/files/tomasulo_paper.pdf&quot; type=&quot;application/pdf; length=782365&quot; title=&quot;tomasulo_paper.pdf&quot;&gt;An Efficient Algorithm for Exploiting Multiple Arithmetic Units by R.M. Tomasulo&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description>
 <pubDate>Fri, 16 Aug 2013 16:05:41 +0000</pubDate>
 <dc:creator>alogie</dc:creator>
 <guid isPermaLink="false">247 at http://cmsc411.com</guid>
 <comments>http://cmsc411.com/hardware/hardware-wars-exploiting-instruction-level-parallelism-ilp#comments</comments>
</item>
</channel>
</rss>
